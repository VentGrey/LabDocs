{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"00-inicio/","text":"\u00a1Bienvenido a los documentos oficiales de Future Lab!","title":"Inicio"},{"location":"00-inicio/#bienvenido-a-los-documentos-oficiales-de-future-lab","text":"","title":"\u00a1Bienvenido a los documentos oficiales de Future Lab!"},{"location":"01-about/","text":"","title":"About"},{"location":"02-reglas/","text":"Espacios de trabajo de FutureLab Los salones designados son: Talleres y cursos. Reuniones y capacitaciones. Oficina. Talleres y cursos Habr\u00e1 un registro de acceso. No est\u00e1 permitida la entrada con alimentos. Respetar el mobiliario. Conservar el orden dentro del espacio. Reuniones y capacitaci\u00f3n No entrar con alimentos. Salvo reuniones o eventos con previa autirzaci\u00f3n. Se asigna como encargado del \u00e1rea a quien se encuentre impartiendo la capacitaci\u00f3n. Se asigna como encargado al host de la reuni\u00f3n. Oficina Solamente est\u00e1 permitido comer snacks (NO CHILAQUILES VERDES CON POLLO) Cada escritorio tiene un espacio personal impl\u00edcito para uso de la persona que se le asigna. Escritorios asignados: Rodolfo Oliver Cristofer Omar Mantener los espacios asignados ordenados","title":"Reglamento"},{"location":"02-reglas/#espacios-de-trabajo-de-futurelab","text":"Los salones designados son: Talleres y cursos. Reuniones y capacitaciones. Oficina. Talleres y cursos Habr\u00e1 un registro de acceso. No est\u00e1 permitida la entrada con alimentos. Respetar el mobiliario. Conservar el orden dentro del espacio. Reuniones y capacitaci\u00f3n No entrar con alimentos. Salvo reuniones o eventos con previa autirzaci\u00f3n. Se asigna como encargado del \u00e1rea a quien se encuentre impartiendo la capacitaci\u00f3n. Se asigna como encargado al host de la reuni\u00f3n. Oficina Solamente est\u00e1 permitido comer snacks (NO CHILAQUILES VERDES CON POLLO) Cada escritorio tiene un espacio personal impl\u00edcito para uso de la persona que se le asigna. Escritorios asignados: Rodolfo Oliver Cristofer Omar Mantener los espacios asignados ordenados","title":"Espacios de trabajo de FutureLab"},{"location":"03-organigrama/","text":"","title":"Organigrama"},{"location":"04-resumen/","text":"","title":"Resumen-Ejecutivo"},{"location":"05-metrics/","text":"Est\u00e1ndares de c\u00f3digo para Future Lab En esta p\u00e1gina se mostrar\u00e1n los estandares de c\u00f3digo utilizados por Future Lab. Los lenguajes soportados (actualmente) por miembros de Future Lab son: C Python 3 Rust JavaScript \u00bfPor qu\u00e9 un est\u00e1ndar? En Future Lab nuestros desarrolladores constantemente colaboran entre s\u00ed para realizar proyectos dentro de las instalaciones, es importante establecer medidas para que el c\u00f3digo enviado a producci\u00f3n sea legible, modular y f\u00e1cil de mantener. C El c\u00f3digo escrito en el lenguaje de programaci\u00f3n C deber\u00e1 seguir los siguientes criterios: Los est\u00e1ndares est\u00e1n escritos para C11. 1- Indentaci\u00f3n Las tabulaciones son de 8 car\u00e1cteres, por lo tanto los indents del c\u00f3digo ser\u00e1n de 8 car\u00e1cteres. Cita sobre los indents de 8 espacios: Algunas personas podr\u00edan decir que tener indents de 8 espacios hace que el c\u00f3digo se mueva mucho hacia la derecha y que \u00e9sto hace que sea dif\u00edcil leer en terminales de 80 car\u00e1cteres. La respuesta a ello es simple, si necesitas m\u00e1s de 3 niveles de indentaci\u00f3n en tu c\u00f3digo, est\u00e1s frito y deber\u00edas de reescribir tu programa. EVITE poner m\u00faltiples sentencias en una l\u00ednea: if ( condici\u00f3n ) hacer_esto : hacer_algo_cada_vez ; 2- Rompe l\u00edneas y cadenas largas El est\u00edlo de c\u00f3digo se hizo para facilitar la lectura y mantenimiento del c\u00f3digo. El l\u00edmite de la longitud de las l\u00edneas en el c\u00f3digo es de 80 columnas. Todas las sentencias mayores a 80 columnas deber\u00e1n ser \"partidas\" en trozos sensibles, a menos que exceder las 80 columnas incremente la facilidad de lectura. Los descendientes de las l\u00edneas o cadenas deber\u00e1n ser menores al padre y se acomodar\u00e1n a la derecha. Lo mismo aplica para las cabeceras de las funciones con varios argumentos. Nunca rompa cadenas visibles al usuario ya que se dificultar\u00eda su b\u00fasqueda. 3- Sobre las llaves y los espacios Otro de los problemas que viene con C es el lugar donde se colocar\u00e1n las llaves y los espacios. A diferencia del tama\u00f1o de los indents existe una raz\u00f3n t\u00e9cnica de porque se deberia de elegir una colocaci\u00f3n sobre otra, aun as\u00ed, la manera que adoptaremos sera la mostrada por los maestros Kernighan & Dennis Ritchie, la cual consiste en poner la llave inicial hasta el final de la l\u00ednea y colocar la llave de cierre al inicio: int main () { printf ( \"Las llaves c\u00f3mo se ven aqu\u00ed :)\" ); } lo mismo aplica para toda sentencia que no sea una funci\u00f3n como: if switch for while do Ej: switch ( acci\u00f3n ) { case caso_1 : return 0 ; case caso_2 : return 0 ; case caso_3 : return 0 ; default : return NULL ; } Existe un caso especial (funciones), en las cuales, algunos programadores colocan la llave de apertura al inicio de la siguiente l\u00ednea: int func_suma ( int x , int y ) { //Cuerpo de la funci\u00f3n. } Muchos han tachado \u00e9sta forma de inconsistente, normalmente por que la gente piensa en 2 cosas: * K & R est\u00e1n bien. * K & R est\u00e1n bien. (Tampoco es que importe mucho ya que no puedes anidar funciones en C). N\u00f3tese que la llave de cierre se considera \"vac\u00eda\" cuando se encuentra sola en una l\u00ednea, excepto en casos donde se contin\u00faa una sentencia previa. Por ejemplo un while en una sentencia do o un else en una sentencia if . do { //Cuerpo de el ciclo do. } while ( condici\u00f3n ); Y if ( x == y ) { .. } else if ( x > y ) { ... } else { .... } Adem\u00e1s, n\u00f3tese que \u00e9ste tipo de acomodo en las llaves minimiza el n\u00famero de l\u00edneas vac\u00edas (o casi vac\u00edas) sin perder nada de facilidad de lectura. Evite poner llaves donde no son necesarias, ergo, donde una sola sentencia es mas que suficiente: if ( condicion ) acci\u00f3n (); y if ( condicion ) acci\u00f3n (); else acci\u00f3n2 (); \u00c9sto no aplica si solo una de las ramas de la sentencia condicional es una es una sentencia sola, en otros casos las llaves ser\u00e1n necesarias: if ( condici\u00f3n ) { acci\u00f3n (); acci\u00f3n2 (); } else { otracosa (); } 3.1- Espacios Use un espacio despu\u00e9s de (la mayor\u00eda) de las palabras reservadas de C. Las excepciones notables con sizeof , typeof , aligof y __attribute__ , las cuales parecen funciones, as\u00ed que use espacios despu\u00e9s de \u00e9stas palabras: if , switch , case , for , do , while Pero no en las palabras anteriormente mencionadas s = sizeof ( struct file ); NO agregue espacios dentro de las expresiones con par\u00e9ntesis: El siguiente ejemplo es lo que NO debe hacer s = sizeof ( struct file ); Cuando declare punteros utilice el operador * adyacente a el nombre del dato o nombre de la funcion y no al nombre del tipo: Bien: char * puntero ; long long super_punteros ( char * puntero ** punteroapuntero ); char * punteros_raros ( subpuntero * s ); Mal: char * puntero ; long long super_punteros ( char * puntero ** punteroapuntero ); char * punteros_raros ( subpuntero * s ); Utilice un espacio en cada lado de los operadores binarios y ternarios: = + - < > * / % | & ^ <= >= == != ? : pero no incluya un espacio despu\u00e9s de los operadoes unarios: & * + - ~ ! sizeof typeof alignof __attribute__ defined No incluya espacios en los operadores unarios de incremento y decremento: ++ -- Y no incluya espacios alrededor de los operadores . y -> . No deje espacios en blanco al final de las l\u00edneas. Algunos editores con indentaci\u00f3n \" inteligente \" van a insertar un espacio en blando al inicio de las nuevas l\u00edneas, asi que usted podr\u00e1 comenzar a tirar c\u00f3digo de inmediato. PERO, algunos editores no eliminan \u00e9ste espacio y uno termina sin agregar c\u00f3digo en la l\u00ednea completa, por lo que uno termina con l\u00edneas con espacios sobrantes: Utilice la selecci\u00f3n de su cursos para notar el siguiente ejemplo: int main () { printf ( \"Soy un c\u00f3digo sin espacios innecesarios :D\" ); } VS int main () { printf ( \"Yo tengo espacios innecesarios :(\" ); } 4- Nombres C es un lenguaje robusto y como lenguaje robusto, los nombres de tus variables deber\u00e1n ser robustos tambi\u00e9n, los programadores en C no utilizan nombres de variables como: EstoEsUnContadorTemporal . Un programador de C llama a su variable tmp , que es muy f\u00e1cil de escribir y no m\u00e1s dif\u00edcil de entender. Sin embargo , aunque los nombres con letras mezcladas (nomeclatura Camello) se ven mal, los nombres descriptivos para las variables son un must . Llamar a una funci\u00f3n o variable global foo es una ofensa. Las variables globales (\u00faselas solo cuando realmente las necesite) deber\u00e1n tener nombres descriptivos, al igual que las funciones globales. Si usted tiene una funci\u00f3n que cuenta el n\u00famero de usuarios activos, deber\u00e1 de llamarla count_active_users() o de una forma similar. NO deber\u00e1 llamarla cntactsrs() . Las variables locales deber\u00e1n de tener nombres cortos y directos al punto. Si usted tiene un contador con de enteros la variable normalmente deberia de llamarse i , llamarla contador_ciclo ser\u00eda ineficiente (por no decir tonto) . simplemente tmp , ese ser\u00eda un buen nombre de variable para un temporal. Si tiene miedo de mezclar nombres de variables entonces tiene otro problema. 5- Typedef Por favor no utilice cosas como vps_t . Es un horror utilizar typedef para estructuras y punteros, cuando vea un: vps_t a; en el c\u00f3digo fuente significa: struct virtual_container *a; y no hace falta explicar que significa a . Normalmente se piensa que los typedefs mejoran la experiencia de lectura , aunque realmente se utilizan para: * Objetos totalmente opacos (donde typedef es para esconder el interior) * Tipos de enteros claros, para evitar confusiones entre int y long . * Nuevos tipos id\u00e9nticos a los de C99. * Son seguros para el userspace 6- Funciones El nombre de las funciones deber\u00e1 de ser corto y preciso. Deber\u00e1n de cabe dentro de una o dos pantallas de texto (la pantalla del ISO/ANSI es de 80x24 como sabemos) y deber\u00e1 hacer una sola cosa y hacerla bien. La longitud m\u00e1xima de una funci\u00f3n es inversamente proporcional a la complejidad y el nivel de indentaci\u00f3n de dicha funcion. Asi que si tienes una funci\u00f3n conceptualmente simple que es una sentencia case larga pero simple donde tienes que hacer muchas evaluaciones peque\u00f1as est\u00e1 bien tener una funci\u00f3n larga. Pero, si tuvi\u00e9se una funci\u00f3n mas compleja y sospechas que un estudiante de tu universidad un poco menos \"agraciado\" que t\u00fa pueda tener problemas entendiendo el c\u00f3digo de la funci\u00f3n es recomendable que se apegue al m\u00e1ximo con el l\u00edmite. Utilice funciones \"ayudantes\" con nombres descriptivos. Otra forma de \"medir\" una funci\u00f3n es por el n\u00famero de variables locales. Normalmente no se deber\u00edan de exceder las 5-10 variables locales, en caso contrario algo estar\u00e1 haciendo mal. Reformule su funci\u00f3n, r\u00f3mpala en pedazos mas peque\u00f1os. Un cerebro humano puede rastrear f\u00e1cilmente a 7 cosas diferentes, una mas y comienza a confundirse. Usted puede sentir que es brillante, pero quiz\u00e1 le gustar\u00eda saber que hizo hace dos semanas. En el c\u00f3digo fuente, separe las funciones con una l\u00ednea en blanco. Si la funci\u00f3n es exportada entonces el macro EXPORT deberia seguir inmediatamente despues de la llave de cierre, ej: int system_is_up ( void ) { return system_state == SYSTEM_RUNNING ; } EXPORT_SYMBOL ( system_is_up ); En los prototipos de las funciones, incluya los nombres de los par\u00e1metros con los tipos de dato. Aunque \u00e9sto no es requerido por C, es preferible dentro de los sistemas tipo Unix porque es una manera mas simple de proporcionale informaci\u00f3n al lector. 7- Salida de funciones centralizada Aunque sea muy odiado por los buenos programadores, el equivalente de la sentencia goto usada frecuentemente por los compiladores en la forma de una instrucci\u00f3n de salto sin condici\u00f3n. La sentencia goto es \u00fatil cuando la funci\u00f3n tiene m\u00faltiples salidas y el mismo trabajo de mantenimiento (como limpieza de memoria) se necesita hacer Si no se necesita hacer limpieza alguna simplemente salga de la funci\u00f3n. Elija nombres de identificador que indique qu\u00e9 hace goto o porque goto existe. Un buen nombre ser\u00eda out_free_buffer: si es que el goto libera el buffer. EVITE utilizar nombres como los de GW-BASIC por ejemplo: err1: y err2: . porque tendr\u00eda que re-enumerarlos si es que agrega o elimina caminos de salida. Las justificaciones para usar goto son: * Las sentencias incondicionales son mas f\u00e1ciles de leer y seguir. * Se reduce el anidado. * Los errores que se dan al no actualizar puntos de salida cuando se hacen modificaciones se evitan. * Le ahorra el trabajo al compilador de optimizar c\u00f3digo redundante. int func ( int a ) { int resultado = 0 ; char * buffer ; buffer = kmalloc ( SIZE , GFP_KERNEL ); if ( ! buffer ) return - ENOMEM ; if ( condicional1 ) { while ( loop1 ) { ... } result = 1 ; goto out_free_buffer ; } ... out_free_buffer : kfree ( buffer ); return resultado ; } Un tipo de error com\u00fan a tener en cuenta es el bug one err que se ve as\u00ed: err : kfree ( foo -> bar ); kfree ( foo ); return ret ; El error de \u00e9ste c\u00f3digo es que algunos caminos de salida para foo son NULL . Normalmente la manera de arreglar \u00e9sto es \"romper\" el c\u00f3digo en 2 identificadores de error err_free_bar: y err_free_foo: : err_free_bar : kfree ( foo -> bar ); err_free_foo : kfree ( foo ); return ret ; Igual evite confiarse y trate de simular errores para probar TODOS sus caminos de salida. 8- Comentarios Los comentarios en el c\u00f3digo siempre son buenos, aunque siempre existe el riesgo de sobre-comentar un c\u00f3digo. NUNCA trate de explicar c\u00f3mo funciona su c\u00f3digo en un comentario: es mucho mejor escribir el c\u00f3digo de manera en la que la funcionalidad sea obvia, ademas es una p\u00e9rdida de tiempo explicar mal c\u00f3digo. Generalemente usted querr\u00e1 explicar QUE hace su c\u00f3digo y no COMO lo hace. Adem\u00e1s, evite poner comentarios dentro del cuerpo de una funci\u00f3n: Si la funci\u00f3n es tan compleja al punto en el que tiene que separarla y poner comentarios para cada parte, probablemente necesite leer el cap\u00edtulo 6 por un buen rato antes de continuar con su c\u00f3digo. Puede hacer peque\u00f1os comentarios para notas o para advertir acerca de algo genial (o muy feo), pero evite excederse. En su lugar ponga los comentarios antes de la funci\u00f3n, indicando que hace y posiblemente por que lo hace. Para comentarios multilinea el estilo preferente es: /* * Este es el estilo preferido para * los comentarios multilinea * dentro de Future Lab * Y los c\u00f3digos en C que se hagan * * Descripci\u00f3n: Un mont\u00f3n de asteriscos en el lado * izquierdo de la pantalla. */ Tambi\u00e9n es importante comentar los datos, sean tipos b\u00e1sicos o derivados. 9- Hiciste un atascadero... Est\u00e1 bien, todos lo hacemos. Probablemente tus queridos amigos te han dicho que editores como Gnu EMACS o GitHub Atom formatean el c\u00f3digo de C de manera autom\u00e1tica y probablemente te hayas dado cuenta de que efectivamente lo hacen pero los valores por defecto que usan van mas all\u00e1 de lo \"horrible\". De hecho son peor que escribir con la cabeza, un n\u00famero infinito de simios escribiendo en \u00e9stos editores con sus valores por defecto jam\u00e1s har\u00edan un buen programa. Lo mismo aplica a cualquier editor del cual se conserven sus valores de edici\u00f3n por defecto. As\u00ed que usted puede eliminar Atom o Gnu EMACS o simplemente cambiar sus valores por unos mas \"correctos\". Incluso si falla en hacer que EMACS o Atom hagan un buen trabajo no todo est\u00e1 perdido, puede usar indent . GNU indent tiene las mismas opciones feas de GNU emacs . Sin embargo indent es d\u00f3cil y f\u00e1cil de modificar ya que los autores de \u00e9ste saben reconocer la autoridad de K&R as\u00ed que, si le damos al programa las opciones -kr -i8 \u00e9ste indentar\u00e1 nuestro c\u00f3digo de una manera correcta. indent tiene un mont\u00f3n de opciones, sobre todo cuando se refiere a re-formatear el c\u00f3digo, solo hace falta un vistazo al manual. Recuerde que indent no es una soluci\u00f3n para Ser un mal programador . Python 3 1- En progreso Uno de nuestros pythoners de Future Lab propondr\u00e1 un estilo de c\u00f3digo uniforme y legible para todos.","title":"Metrics"},{"location":"05-metrics/#estandares-de-codigo-para-future-lab","text":"En esta p\u00e1gina se mostrar\u00e1n los estandares de c\u00f3digo utilizados por Future Lab. Los lenguajes soportados (actualmente) por miembros de Future Lab son: C Python 3 Rust JavaScript","title":"Est\u00e1ndares de c\u00f3digo para Future Lab"},{"location":"05-metrics/#por-que-un-estandar","text":"En Future Lab nuestros desarrolladores constantemente colaboran entre s\u00ed para realizar proyectos dentro de las instalaciones, es importante establecer medidas para que el c\u00f3digo enviado a producci\u00f3n sea legible, modular y f\u00e1cil de mantener.","title":"\u00bfPor qu\u00e9 un est\u00e1ndar?"},{"location":"05-metrics/#c","text":"El c\u00f3digo escrito en el lenguaje de programaci\u00f3n C deber\u00e1 seguir los siguientes criterios: Los est\u00e1ndares est\u00e1n escritos para C11.","title":"C"},{"location":"05-metrics/#1-indentacion","text":"Las tabulaciones son de 8 car\u00e1cteres, por lo tanto los indents del c\u00f3digo ser\u00e1n de 8 car\u00e1cteres. Cita sobre los indents de 8 espacios: Algunas personas podr\u00edan decir que tener indents de 8 espacios hace que el c\u00f3digo se mueva mucho hacia la derecha y que \u00e9sto hace que sea dif\u00edcil leer en terminales de 80 car\u00e1cteres. La respuesta a ello es simple, si necesitas m\u00e1s de 3 niveles de indentaci\u00f3n en tu c\u00f3digo, est\u00e1s frito y deber\u00edas de reescribir tu programa. EVITE poner m\u00faltiples sentencias en una l\u00ednea: if ( condici\u00f3n ) hacer_esto : hacer_algo_cada_vez ;","title":"1- Indentaci\u00f3n"},{"location":"05-metrics/#2-rompe-lineas-y-cadenas-largas","text":"El est\u00edlo de c\u00f3digo se hizo para facilitar la lectura y mantenimiento del c\u00f3digo. El l\u00edmite de la longitud de las l\u00edneas en el c\u00f3digo es de 80 columnas. Todas las sentencias mayores a 80 columnas deber\u00e1n ser \"partidas\" en trozos sensibles, a menos que exceder las 80 columnas incremente la facilidad de lectura. Los descendientes de las l\u00edneas o cadenas deber\u00e1n ser menores al padre y se acomodar\u00e1n a la derecha. Lo mismo aplica para las cabeceras de las funciones con varios argumentos. Nunca rompa cadenas visibles al usuario ya que se dificultar\u00eda su b\u00fasqueda.","title":"2- Rompe l\u00edneas y cadenas largas"},{"location":"05-metrics/#3-sobre-las-llaves-y-los-espacios","text":"Otro de los problemas que viene con C es el lugar donde se colocar\u00e1n las llaves y los espacios. A diferencia del tama\u00f1o de los indents existe una raz\u00f3n t\u00e9cnica de porque se deberia de elegir una colocaci\u00f3n sobre otra, aun as\u00ed, la manera que adoptaremos sera la mostrada por los maestros Kernighan & Dennis Ritchie, la cual consiste en poner la llave inicial hasta el final de la l\u00ednea y colocar la llave de cierre al inicio: int main () { printf ( \"Las llaves c\u00f3mo se ven aqu\u00ed :)\" ); } lo mismo aplica para toda sentencia que no sea una funci\u00f3n como: if switch for while do Ej: switch ( acci\u00f3n ) { case caso_1 : return 0 ; case caso_2 : return 0 ; case caso_3 : return 0 ; default : return NULL ; } Existe un caso especial (funciones), en las cuales, algunos programadores colocan la llave de apertura al inicio de la siguiente l\u00ednea: int func_suma ( int x , int y ) { //Cuerpo de la funci\u00f3n. } Muchos han tachado \u00e9sta forma de inconsistente, normalmente por que la gente piensa en 2 cosas: * K & R est\u00e1n bien. * K & R est\u00e1n bien. (Tampoco es que importe mucho ya que no puedes anidar funciones en C). N\u00f3tese que la llave de cierre se considera \"vac\u00eda\" cuando se encuentra sola en una l\u00ednea, excepto en casos donde se contin\u00faa una sentencia previa. Por ejemplo un while en una sentencia do o un else en una sentencia if . do { //Cuerpo de el ciclo do. } while ( condici\u00f3n ); Y if ( x == y ) { .. } else if ( x > y ) { ... } else { .... } Adem\u00e1s, n\u00f3tese que \u00e9ste tipo de acomodo en las llaves minimiza el n\u00famero de l\u00edneas vac\u00edas (o casi vac\u00edas) sin perder nada de facilidad de lectura. Evite poner llaves donde no son necesarias, ergo, donde una sola sentencia es mas que suficiente: if ( condicion ) acci\u00f3n (); y if ( condicion ) acci\u00f3n (); else acci\u00f3n2 (); \u00c9sto no aplica si solo una de las ramas de la sentencia condicional es una es una sentencia sola, en otros casos las llaves ser\u00e1n necesarias: if ( condici\u00f3n ) { acci\u00f3n (); acci\u00f3n2 (); } else { otracosa (); }","title":"3- Sobre las llaves y los espacios"},{"location":"05-metrics/#31-espacios","text":"Use un espacio despu\u00e9s de (la mayor\u00eda) de las palabras reservadas de C. Las excepciones notables con sizeof , typeof , aligof y __attribute__ , las cuales parecen funciones, as\u00ed que use espacios despu\u00e9s de \u00e9stas palabras: if , switch , case , for , do , while Pero no en las palabras anteriormente mencionadas s = sizeof ( struct file ); NO agregue espacios dentro de las expresiones con par\u00e9ntesis: El siguiente ejemplo es lo que NO debe hacer s = sizeof ( struct file ); Cuando declare punteros utilice el operador * adyacente a el nombre del dato o nombre de la funcion y no al nombre del tipo: Bien: char * puntero ; long long super_punteros ( char * puntero ** punteroapuntero ); char * punteros_raros ( subpuntero * s ); Mal: char * puntero ; long long super_punteros ( char * puntero ** punteroapuntero ); char * punteros_raros ( subpuntero * s ); Utilice un espacio en cada lado de los operadores binarios y ternarios: = + - < > * / % | & ^ <= >= == != ? : pero no incluya un espacio despu\u00e9s de los operadoes unarios: & * + - ~ ! sizeof typeof alignof __attribute__ defined No incluya espacios en los operadores unarios de incremento y decremento: ++ -- Y no incluya espacios alrededor de los operadores . y -> . No deje espacios en blanco al final de las l\u00edneas. Algunos editores con indentaci\u00f3n \" inteligente \" van a insertar un espacio en blando al inicio de las nuevas l\u00edneas, asi que usted podr\u00e1 comenzar a tirar c\u00f3digo de inmediato. PERO, algunos editores no eliminan \u00e9ste espacio y uno termina sin agregar c\u00f3digo en la l\u00ednea completa, por lo que uno termina con l\u00edneas con espacios sobrantes: Utilice la selecci\u00f3n de su cursos para notar el siguiente ejemplo: int main () { printf ( \"Soy un c\u00f3digo sin espacios innecesarios :D\" ); } VS int main () { printf ( \"Yo tengo espacios innecesarios :(\" ); }","title":"3.1- Espacios"},{"location":"05-metrics/#4-nombres","text":"C es un lenguaje robusto y como lenguaje robusto, los nombres de tus variables deber\u00e1n ser robustos tambi\u00e9n, los programadores en C no utilizan nombres de variables como: EstoEsUnContadorTemporal . Un programador de C llama a su variable tmp , que es muy f\u00e1cil de escribir y no m\u00e1s dif\u00edcil de entender. Sin embargo , aunque los nombres con letras mezcladas (nomeclatura Camello) se ven mal, los nombres descriptivos para las variables son un must . Llamar a una funci\u00f3n o variable global foo es una ofensa. Las variables globales (\u00faselas solo cuando realmente las necesite) deber\u00e1n tener nombres descriptivos, al igual que las funciones globales. Si usted tiene una funci\u00f3n que cuenta el n\u00famero de usuarios activos, deber\u00e1 de llamarla count_active_users() o de una forma similar. NO deber\u00e1 llamarla cntactsrs() . Las variables locales deber\u00e1n de tener nombres cortos y directos al punto. Si usted tiene un contador con de enteros la variable normalmente deberia de llamarse i , llamarla contador_ciclo ser\u00eda ineficiente (por no decir tonto) . simplemente tmp , ese ser\u00eda un buen nombre de variable para un temporal. Si tiene miedo de mezclar nombres de variables entonces tiene otro problema.","title":"4- Nombres"},{"location":"05-metrics/#5-typedef","text":"Por favor no utilice cosas como vps_t . Es un horror utilizar typedef para estructuras y punteros, cuando vea un: vps_t a; en el c\u00f3digo fuente significa: struct virtual_container *a; y no hace falta explicar que significa a . Normalmente se piensa que los typedefs mejoran la experiencia de lectura , aunque realmente se utilizan para: * Objetos totalmente opacos (donde typedef es para esconder el interior) * Tipos de enteros claros, para evitar confusiones entre int y long . * Nuevos tipos id\u00e9nticos a los de C99. * Son seguros para el userspace","title":"5- Typedef"},{"location":"05-metrics/#6-funciones","text":"El nombre de las funciones deber\u00e1 de ser corto y preciso. Deber\u00e1n de cabe dentro de una o dos pantallas de texto (la pantalla del ISO/ANSI es de 80x24 como sabemos) y deber\u00e1 hacer una sola cosa y hacerla bien. La longitud m\u00e1xima de una funci\u00f3n es inversamente proporcional a la complejidad y el nivel de indentaci\u00f3n de dicha funcion. Asi que si tienes una funci\u00f3n conceptualmente simple que es una sentencia case larga pero simple donde tienes que hacer muchas evaluaciones peque\u00f1as est\u00e1 bien tener una funci\u00f3n larga. Pero, si tuvi\u00e9se una funci\u00f3n mas compleja y sospechas que un estudiante de tu universidad un poco menos \"agraciado\" que t\u00fa pueda tener problemas entendiendo el c\u00f3digo de la funci\u00f3n es recomendable que se apegue al m\u00e1ximo con el l\u00edmite. Utilice funciones \"ayudantes\" con nombres descriptivos. Otra forma de \"medir\" una funci\u00f3n es por el n\u00famero de variables locales. Normalmente no se deber\u00edan de exceder las 5-10 variables locales, en caso contrario algo estar\u00e1 haciendo mal. Reformule su funci\u00f3n, r\u00f3mpala en pedazos mas peque\u00f1os. Un cerebro humano puede rastrear f\u00e1cilmente a 7 cosas diferentes, una mas y comienza a confundirse. Usted puede sentir que es brillante, pero quiz\u00e1 le gustar\u00eda saber que hizo hace dos semanas. En el c\u00f3digo fuente, separe las funciones con una l\u00ednea en blanco. Si la funci\u00f3n es exportada entonces el macro EXPORT deberia seguir inmediatamente despues de la llave de cierre, ej: int system_is_up ( void ) { return system_state == SYSTEM_RUNNING ; } EXPORT_SYMBOL ( system_is_up ); En los prototipos de las funciones, incluya los nombres de los par\u00e1metros con los tipos de dato. Aunque \u00e9sto no es requerido por C, es preferible dentro de los sistemas tipo Unix porque es una manera mas simple de proporcionale informaci\u00f3n al lector.","title":"6- Funciones"},{"location":"05-metrics/#7-salida-de-funciones-centralizada","text":"Aunque sea muy odiado por los buenos programadores, el equivalente de la sentencia goto usada frecuentemente por los compiladores en la forma de una instrucci\u00f3n de salto sin condici\u00f3n. La sentencia goto es \u00fatil cuando la funci\u00f3n tiene m\u00faltiples salidas y el mismo trabajo de mantenimiento (como limpieza de memoria) se necesita hacer Si no se necesita hacer limpieza alguna simplemente salga de la funci\u00f3n. Elija nombres de identificador que indique qu\u00e9 hace goto o porque goto existe. Un buen nombre ser\u00eda out_free_buffer: si es que el goto libera el buffer. EVITE utilizar nombres como los de GW-BASIC por ejemplo: err1: y err2: . porque tendr\u00eda que re-enumerarlos si es que agrega o elimina caminos de salida. Las justificaciones para usar goto son: * Las sentencias incondicionales son mas f\u00e1ciles de leer y seguir. * Se reduce el anidado. * Los errores que se dan al no actualizar puntos de salida cuando se hacen modificaciones se evitan. * Le ahorra el trabajo al compilador de optimizar c\u00f3digo redundante. int func ( int a ) { int resultado = 0 ; char * buffer ; buffer = kmalloc ( SIZE , GFP_KERNEL ); if ( ! buffer ) return - ENOMEM ; if ( condicional1 ) { while ( loop1 ) { ... } result = 1 ; goto out_free_buffer ; } ... out_free_buffer : kfree ( buffer ); return resultado ; } Un tipo de error com\u00fan a tener en cuenta es el bug one err que se ve as\u00ed: err : kfree ( foo -> bar ); kfree ( foo ); return ret ; El error de \u00e9ste c\u00f3digo es que algunos caminos de salida para foo son NULL . Normalmente la manera de arreglar \u00e9sto es \"romper\" el c\u00f3digo en 2 identificadores de error err_free_bar: y err_free_foo: : err_free_bar : kfree ( foo -> bar ); err_free_foo : kfree ( foo ); return ret ; Igual evite confiarse y trate de simular errores para probar TODOS sus caminos de salida.","title":"7- Salida de funciones centralizada"},{"location":"05-metrics/#8-comentarios","text":"Los comentarios en el c\u00f3digo siempre son buenos, aunque siempre existe el riesgo de sobre-comentar un c\u00f3digo. NUNCA trate de explicar c\u00f3mo funciona su c\u00f3digo en un comentario: es mucho mejor escribir el c\u00f3digo de manera en la que la funcionalidad sea obvia, ademas es una p\u00e9rdida de tiempo explicar mal c\u00f3digo. Generalemente usted querr\u00e1 explicar QUE hace su c\u00f3digo y no COMO lo hace. Adem\u00e1s, evite poner comentarios dentro del cuerpo de una funci\u00f3n: Si la funci\u00f3n es tan compleja al punto en el que tiene que separarla y poner comentarios para cada parte, probablemente necesite leer el cap\u00edtulo 6 por un buen rato antes de continuar con su c\u00f3digo. Puede hacer peque\u00f1os comentarios para notas o para advertir acerca de algo genial (o muy feo), pero evite excederse. En su lugar ponga los comentarios antes de la funci\u00f3n, indicando que hace y posiblemente por que lo hace. Para comentarios multilinea el estilo preferente es: /* * Este es el estilo preferido para * los comentarios multilinea * dentro de Future Lab * Y los c\u00f3digos en C que se hagan * * Descripci\u00f3n: Un mont\u00f3n de asteriscos en el lado * izquierdo de la pantalla. */ Tambi\u00e9n es importante comentar los datos, sean tipos b\u00e1sicos o derivados.","title":"8- Comentarios"},{"location":"05-metrics/#9-hiciste-un-atascadero","text":"Est\u00e1 bien, todos lo hacemos. Probablemente tus queridos amigos te han dicho que editores como Gnu EMACS o GitHub Atom formatean el c\u00f3digo de C de manera autom\u00e1tica y probablemente te hayas dado cuenta de que efectivamente lo hacen pero los valores por defecto que usan van mas all\u00e1 de lo \"horrible\". De hecho son peor que escribir con la cabeza, un n\u00famero infinito de simios escribiendo en \u00e9stos editores con sus valores por defecto jam\u00e1s har\u00edan un buen programa. Lo mismo aplica a cualquier editor del cual se conserven sus valores de edici\u00f3n por defecto. As\u00ed que usted puede eliminar Atom o Gnu EMACS o simplemente cambiar sus valores por unos mas \"correctos\". Incluso si falla en hacer que EMACS o Atom hagan un buen trabajo no todo est\u00e1 perdido, puede usar indent . GNU indent tiene las mismas opciones feas de GNU emacs . Sin embargo indent es d\u00f3cil y f\u00e1cil de modificar ya que los autores de \u00e9ste saben reconocer la autoridad de K&R as\u00ed que, si le damos al programa las opciones -kr -i8 \u00e9ste indentar\u00e1 nuestro c\u00f3digo de una manera correcta. indent tiene un mont\u00f3n de opciones, sobre todo cuando se refiere a re-formatear el c\u00f3digo, solo hace falta un vistazo al manual. Recuerde que indent no es una soluci\u00f3n para Ser un mal programador .","title":"9- Hiciste un atascadero..."},{"location":"05-metrics/#python-3","text":"","title":"Python 3"},{"location":"05-metrics/#1-en-progreso","text":"Uno de nuestros pythoners de Future Lab propondr\u00e1 un estilo de c\u00f3digo uniforme y legible para todos.","title":"1- En progreso"}]}